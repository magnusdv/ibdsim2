% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ibdsim.R
\name{ibdsim}
\alias{ibdsim}
\title{IBD simulation}
\usage{
ibdsim(
  x,
  N = 1,
  ids = labels(x),
  map = "decode",
  chrom = NULL,
  model = c("chi", "haldane"),
  skipRecomb = NULL,
  seed = NULL,
  verbose = TRUE
)
}
\arguments{
\item{x}{A \code{\link[pedtools:ped]{pedtools::ped()}} object.}

\item{N}{A positive integer indicating the number of simulations.}

\item{ids}{A subset of pedigree members whose IBD sharing should be analysed.
If NULL, the simulations are returned unprocessed.}

\item{map}{The genetic map to be used in the simulations: One of the
character strings "decode", "uniform.sex.spec", "uniform.sex.aver". (See
Details.)}

\item{chrom}{A numeric vector indicating chromosome numbers, or either of the
words "AUTOSOMAL" or "X". The default is 1:22, i.e., the human autosomes.}

\item{model}{Either "chi" (default) or "haldane", indicating the statistical
model for recombination. (See details.)}

\item{skipRecomb}{A vector of ID labels indicating individuals whose meioses
should be simulated without recombination. (Each child will then receive a
random strand of each chromosome.) By default (\code{skipRecomb = NULL}) the
following individuals are skipped:
\itemize{
\item If \code{length(ids) > 1}: founders of \code{x} who are not common ancestors of
\code{ids}
\item If \code{ids} consist of a single nonfounder: founders of \code{x} who are not
common ancestors of the parents.
\item Otherwise: None.
}}

\item{seed}{An integer to be passed on to \code{\link[=set.seed]{set.seed()}}).}

\item{verbose}{A logical.}
}
\value{
A list of \code{genomeSim} objects.

A \code{genomeSim} object is essentially a numerical matrix describing the
allele flow through the pedigree in a single simulated. Each row
corresponds to a chromosomal segment. The first 4 columns describe the
segment (chromosome, start, end, length), and are followed by two columns
(paternal allele, maternal allele) for each of the selected individuals. If
\code{length(ids) == 2} two additional columns are added:
\itemize{
\item \code{IBD} : The IBD status of each segment (= number of alleles shared
identical by descent). For a given segment, the IBD status is either 0, 1,
2 or NA. If either individual is inbred, they may be autozygous in a
segment, in which case the IBD status is reported as NA. With inbred
individuals the \code{Sigma} column (see below) is more informative than the
\code{IBD} column.
\item \code{Sigma} : The condensed identity ("Jacquard") state of each segment,
given as an integer in the range 1-9. The numbers correspond to the
standard ordering of the condensed states. In particular, for non-inbred
individuals the states 9, 8, 7 correspond to IBD status 0, 1, 2
respectively.
}
}
\description{
This is the main function of the package, simulating the recombination
process in each meioses of a pedigree. The output summarises the IBD segments
between all or a subset of individuals.
}
\details{
Each simulation starts by unique alleles being distributed to the pedigree
founders. In each meiosis, homologue chromosomes are made to recombine
according to a renewal process along the four-strand bundle, with chi square
distributed waiting times. (For comparison purposes, Haldane's Poisson model
for recombination is also implemented.)

Recombination rates are sex-dependent, and vary along each chromosome
according to the recombination map specified by the \code{map} parameter. By
default, the complete Decode map of the human autosome is used (see
References). If \code{map = "uniform.sex.spec"}, the genetic chromosome \emph{lengths}
are as in the Decode map, but the recombination rate is kept constant along
each chromosome. If \code{map = "uniform.sex.aver"}, sex averaged genetic
chromosome lengths are used (and constant recombination rates along each
chromosome).
}
\examples{

hs = halfSibPed()
ibdsim(hs, N = 2, map = uniformMap(M = 1), ids = 4:5)

# Full sib mating: all 9 states are possible
x = fullSibMating(1)
sim = ibdsim(x, N = 1, ids = 5:6, map = uniformMap(M = 10), seed = 1)
s = sim[[1]]
stopifnot(setequal(s[, 'Sigma'], 1:9))

}
